/*  DO NOT EDIT THIS FILE.

    It has been auto-edited by fixincludes from:

	"/usr/local/te/tool/Linux-i686/arm_2-unknown-tkernel/sys-include/stdio.h"

    This had to be done to correct non-standard usages in the
    original, manufacturer supplied header file.  */

/*
 *	@(#)stdio.h 03-12-10
 *
 *	C 言語：入出力
 *	Copyright (C) 2002-2003 by Personal Media Corporation
 *
 *	★印のある関数は、UNIX エミュレータが必須である。
 *	☆印のある関数は、UNIX エミュレータががない場合、stdin, stdout, stderr
 *	を指定することはできない。
 *
 *	UNIX エミュレータがない場合は、BTRON ファイルシステムのみの対応となる。
 *	UNIX エミュレータがある場合は、UNIX エミュレータの対応するファイルシス
 *	テム(FAT, ISO 9660)も使用できる。
 *
 *	UNIX エミュレータを使用する場合、および BTRON ファイルシステムを使用す
 *	る場合は、プロセスのコンテキストから呼び出す必要がある。
 *	UNIX エミュレータを使用しない場合、コンソール I/O のみはプロセスの環境
 *	を必要としない。UNIX エミュレータを使用する場合は、コンソールもプロセス
 *	のコンテキストから呼び出す必要がある。
 *
 *	プロセスとして起動されるプログラムは、UNIX エミュレータがある場合は自動
 *	的に UNIX エミュレータを使用するように設定される。
 *	プロセスではない T-Kernel ベースのプログラムは、UNIX エミュレータがあっ
 *	ても自動的には UNIX エミュレータを使用するようには設定されない。
 *
 *	コンソール I/O のみの環境の場合
 *	stdin, stdout, stderr のみ使用可能。
 *	fopen() や freopen() などでファイルをオープンすることはできない。
 *	stdin, stdout, stderr を fclose() することはできない。
 *	ungetc() が使用できない。
 *	scanf() 系の関数では、ungetc() が使用できないため、１行を複数回に分け
 *	て変換した場合に正しく動作しないことがある。
 */

#ifndef	__STDIO_H__
#define	__STDIO_H__

#include "stdtype.h"
#include "stdarg.h"
#include "btron/typedef.h"

#ifdef __cplusplus
extern "C" {
#endif

#define	NULL		0

#ifdef	__size_t
typedef __size_t	size_t;
#undef	__size_t
#endif

#ifdef	__off_t
typedef __off_t		off_t;
#undef	__off_t
#endif

typedef struct _FILE	FILE;		/* ファイルハンドル */

typedef	struct {
	off_t		fpos;		/* ファイル(レコード)内の位置 */
	int		recno;		/* レコード番号 */
} fpos_t;

#define	EOF		(-1)		/* ファイル終端 */

#define	_IOFBF		0		/* 完全バッファリングモード */
#define	_IOLBF		1		/* 行バッファリングモード */
#define	_IONBF		2		/* 非バッファリングモード */

#define	BUFSIZ		1024		/* バッファサイズ	最小 256 */
#define	FOPEN_MAX	20		/* オープンファイル数	最小 8 */
#define	FILENAME_MAX	256		/* ファイル名長 */
#define	TMP_MAX		25		/* 一時ファイル数	最小 25 */
#define	L_tmpnam	16		/* 一時ファイル名長 */

#define	SEEK_SET	0		/* 先頭から */
#define	SEEK_CUR	1		/* 現在位置から */
#define	SEEK_END	2		/* 終端から */

extern FILE		*__stdin, *__stdout, *__stderr;
#define	stdin		__stdin		/* 標準入力 */
#define	stdout		__stdout	/* 標準出力 */
#define	stderr		__stderr	/* 標準エラー出力 */

/* ファイルに対する操作
 *	一時ファイル名は次の形式
 *	/SYS/tmp/_#####
 *	# は乱数で、5 桁以下の10進数
 */
extern int remove( const char *filename );				/*★*/
extern int rename( const char *oldname, const char *newname );		/*★*/
extern FILE* tmpfile( void );						/*★*/
extern char* tmpnam( char *s );						/*★*/

/* ファイルアクセス関数
 *	BTRON ファイルシステムの場合、オープンモード(mode)でレコード番号または
 *	レコードタイプが指定できる。通常のオープンモード文字列に続けて、レコー
 *	ド番号(≧0)またはレコードタイプ(-1〜-31)を10進数で指定する。レコードタ
 *	イプは、負数(-rectype)で指定する。レコードタイプ指定の場合、先頭レコー
 *	ドから検索し、最初に見つかった指定レコードタイプのレコードとなる。
 *	指定されたレコードが見つからない場合、"r" の場合はエラーとなる。"w","a"
 *	の場合は、レコード番号指定の場合はレコードタイプ 31、レコードタイプ指定
 *	の場合は指定されたタイプのレコードを新規に作成し、一番最後のレコードと
 *	して追加する。
 *	レコード番号・レコードタイプの指定がない場合は、レコードタイプ 31 が指
 *	定されたのと等価となる。(UNIX エミュレータの仕様)
 *	(例) "w 12"	レコード番号 12 のレコードを書き込みモードでオープン
 *	     "r+ -16"	レコードタイプ 16 のレコードを更新モードでオープン
 *	     "a"	レコードタイプ 31 のレコードを追加モードでオープン
 */
extern FILE* fopen( const char *filename, const char *mode );
extern FILE* freopen( const char *filename, const char *mode, FILE* );	/*☆*/
extern int fclose( FILE* );						/*☆*/
extern int fflush( FILE* );
extern void setbuf( FILE*, char *buf );					/*☆*/
extern int setvbuf( FILE*, char *buf, int mode, size_t size );		/*☆*/

/*	fildes は UNIX エミュレータの open() で返されるファイルディスクリプタ、
 *	または、BTRON の opn_fil(), cre_fil() で返されるファイルディスクリプタ
 *	のいずれかである。
 *	fildes がどちらのファイルディスクリプタであるかを明示する必要がある。
 *	オープンモード(mode)にレコード番号またはレコードタイプの指定を含む場合
 *	は BTRON のファイルディスクリプタ、そうでない場合は UNIX エミュレータ
 *	のファイルディスクリプタとなる。
 */
extern FILE* fdopen( int fildes, const char *mode );

/*	TCP/IP マネージャーで生成したソケットを FILE に対応づける。
 *	fdopen() に相当する、ソケット専用のオープン関数である。
 *	fildes には、so_socket() 等で取得したディスクリプタを指定する。
 *	FILE は、行バッファリングモード(_IOLBF)に設定される。
 *	同じ fildes で複数回 sdopen() した場合(多重オープンした場合)、
 *	同じ fildes に対する最後の fclose() 時にのみ so_close() が
 *	呼び出される。
 */
extern FILE* sdopen( int fildes, const char *mode );

/* BTRON ファイル特有のオープン関数
 *	TC のファイル名は、BTRON 仕様に基づくパス名。つまり、パス名の区切りは
 *	'／'などの一般文字ではなく、特殊コード(TC_FDLM,TC_FSEP,TC_FOWN)である。
 *	また、ファイル名には言語指定コードを含むこともできる。
 *	LINK 指定の場合、存在しないファイルを指定することはできない。
 */
extern FILE* tfopen( const TC *filename, const char *mode );
extern FILE* tflopen( const LINK *lnk, const char *mode );

/* BTRON ファイル特有のレコード移動関数
 *	これらの関数を使用する場合は、ファイルをオープンするときに明示的にレコ
 *	ード番号またはレコードタイプを指定し、BTRON ファイルとしてオープンしな
 *	ければならない。
 * tffndrec()
 *	mode, typemask, subtype は fnd_rec() の指定と同じ。
 *	戻値に移動先のレコードタイプを返す。エラーのときは EOF を返す。
 * tfseerec()
 *	whence
 *	SEEK_SET	offset の位置へ移動
 *	SEEK_CUR	現在レコード + offset の位置へ移動
 *	SEEK_END	終端レコード + offset の位置へ移動
 *	戻値に移動先のレコードタイプを返す。エラーのときは EOF を返す。
 * tfrecnum()
 *	戻値に現在レコード番号を返す。
 *	エラーはないが、レコード移動に失敗したあとのレコード番号が有効である
 *	ことは保証されない。
 */
extern int tffndrec( FILE*, int mode, unsigned long typemask, int subtype );
extern int tfseerec( FILE*, int offset, int whence );
extern int tfrecnum( FILE* );

/* 書式付入出力関数
 *	変換指定子に下記を追加
 *	S: TC 文字列
 *	C: TC 文字
 */
extern int fscanf( FILE*, const char *format, ... );
extern int scanf( const char *format, ... );
extern int sscanf( const char *s, const char *format, ... );
extern int vfscanf( FILE*, const char *format, __gnuc_va_list arg );
extern int vscanf( const char *format, __gnuc_va_list arg );
extern int vsscanf( const char *s, const char *format, __gnuc_va_list arg );

extern int fprintf( FILE*, const char *format, ... );
extern int printf( const char *format, ... );
extern int sprintf( char *s, const char *format, ... );
extern int vfprintf( FILE*, const char *format, __gnuc_va_list arg );
extern int vprintf( const char *format, __gnuc_va_list arg );
extern int vsprintf( char *s, const char *format, __gnuc_va_list arg );

extern int asprintf( char **result, const char *format, ... );
extern int snprintf( char *s, size_t max, const char *format, ... );
extern int vasprintf( char **result, const char *format, __gnuc_va_list arg );
extern int vsnprintf( char *s, size_t max, const char *format, __gnuc_va_list arg );

/* 文字入出力関数 */
extern int fputc( int c, FILE* );
extern int putc( int c, FILE* );
extern int putchar( int c );
extern int fputs( const char *s, FILE* );
extern int puts( const char *s );
extern int fgetc( FILE* );
extern int getc( FILE* );
extern int getchar( void );
extern char* fgets( char *s, int n, FILE* );
extern char* gets( char *s );
extern int ungetc( int c, FILE* );					/*☆*/

/* 直接入出力関数 */
extern size_t fread( void *ptr, size_t size, size_t nmemb, FILE* );	/*☆*/
extern size_t fwrite( const void *ptr, size_t size, size_t nmemb, FILE* );
									/*☆*/

/* ファイル位置付け関数 */
extern int fseek( FILE*, long int offset, int whence );			/*☆*/
extern int fgetpos( FILE*, fpos_t *pos );				/*☆*/
extern int fsetpos( FILE*, const fpos_t *pos );				/*☆*/
extern long int ftell( FILE* );						/*☆*/
extern void rewind( FILE* );						/*☆*/

/* エラー処理関数 */
extern void clearerr( FILE* );						/*☆*/
extern int feof( FILE* );						/*☆*/
extern int ferror( FILE* );						/*☆*/
extern void perror( const char *s );  /* 暫定的対応(エラーコードの表示のみ) */

/*
 * 待たずに読み出せるデータ量を求める
 *	戻値	≧0 データ量 (バイト数)
 *		エラーまたは終端のとき EOF
 *
 *	端末の場合は、バッファに溜っている文字が対象となる。
 *	ファイルの場合は、ファイルの終端までのサイズとなる。
 *	(030901) 現在の実装では、ファイル以外は常に 0 が返る。
 */
extern int fhowmanyc( FILE* );

#define	getc(fp)	fgetc(fp)
#define	getchar()	fgetc(stdin)
#define	putc(c, fp)	fputc(c, fp)
#define	putchar(c)	fputc(c, stdout)

#ifdef __cplusplus
}
#endif
#endif	/* __STDIO_H__ */
